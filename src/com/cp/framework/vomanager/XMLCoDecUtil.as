package com.cp.framework.vomanager
{
	import flash.utils.Dictionary;
	import flash.utils.getDefinitionByName;

	import mx.collections.IList;
	import mx.rpc.xml.TypeIterator;
	import mx.utils.DescribeTypeCache;
	import mx.utils.ObjectProxy;

	/**
	 * VOUtil act as a facade of the functions provided in IValueObject interface, it also
	 * provides functions to handle default (common) behaviors of an IValueObject implementer.
	 */
	public class XMLCoDecUtil
	{
		private static var collectionTypeCache:Dictionary = new Dictionary();

		/**
		 * <p>Parse an XML to an IValueObject implementor.</p>
		 * <p>Some pre-conditions:<br/>
		 * <ol>
		 *    <li>vo (the IValueObject implementor) should have defined a default voFieldMap, but you can always overwrite that
		 *        by passing in a customized voFieldMap object, though it is not recommended</li>
		 *    <li>both vo and xml shouldn't be empty (or null)</li>
		 *    <li>defaultValue allows you to ensure one or more properties to receive a defaultValue at run time, per service call</li>
		 *    <li>values of voFieldMap should be either a string (servers most default cases), or a function with the following signature:<br/>
		 *        <code>function (xml:XML):void</code>.<br/>
		 *        such function is assumed to be defined within the value object, and only to parse complex xml structures.<br/>
		 *        in case of the value is being a string, a decoder function will be generated by calling <code>primitiveDecoderMaker</code>
		 *    </li>
		 * </ol>
		 */
		public static function fromXML(vo:IValueObject, xml:XML, codec:IXMLCoDec=null, defaultValues:Object=null):void
		{
			if (!codec)
				codec = vo.codec as IXMLCoDec;

			if (!defaultValues)
				defaultValues = {};

			for (var voFieldName:String in codec.decodeMap)
			{
				var xmlFieldName:* = codec.decodeMap[voFieldName];
				var xmlCoDec:IXMLCoDec = xmlFieldName as IXMLCoDec;
				if (xmlCoDec != null)
				{
					var matches:XMLList = xml.child(voFieldName);
					if (matches.length() > 0)
						fromXML(vo, matches[0], xmlCoDec, defaultValues);
				}
				else
				{
					var xmlFieldDecoder:Function = xmlFieldName as Function;
					if (xmlFieldDecoder == null)
						xmlFieldDecoder = primitiveDecoderMaker(voFieldName, xmlFieldName);

					xmlFieldDecoder(xml, vo, defaultValues);
				}
			}
		}

		public static function toXML(vo:IValueObject, codec:IXMLCoDec=null):XML
		{
			if (!codec)
				codec = vo.codec as IXMLCoDec;

			var xml:XML = <{codec.rootName} />;

			for (var xmlFieldName:String in codec.encodeMap)
			{
				var voFieldName:* = codec.encodeMap[xmlFieldName];
				var xmlCoDec:IXMLCoDec = voFieldName as IXMLCoDec;
				if (xmlCoDec != null)
				{
					var childXML:XML = toXML(vo, xmlCoDec);
					xml.appendChild(childXML);
				}
				else
				{
					if (!voFieldName)
						throw new Error('xml property: "' + xmlFieldName + '" has no property mapping found in vo: ' + vo);

					var xmlEncoder:Function = voFieldName as Function;
					if (xmlEncoder == null)
						xmlEncoder = xmlEncoderMaker(voFieldName, xmlFieldName);
					var xmlList:XMLList = XMLList(xmlEncoder(vo));
					for (var i:int = 0; i < xmlList.length(); i++)
						xml.child(xmlFieldName)[i] = xmlList[i];
				}
			}

			return xml;
		}

		public static function voListToXML(list:IList, rootName:String, codec:IXMLCoDec=null):XML
		{
			var xml:XML = <{rootName} />;
			for each (var vo:IValueObject in list)
				xml.appendChild(toXML(vo, codec));

			return xml;
		}

		public static function primitiveDecoderMaker(voFieldName:String, xmlFieldName:String=null, setOnlyIfNotNull:Boolean=false):Function
		{
			if (xmlFieldName == null)
				xmlFieldName = voFieldName;

			return function(xml:XML, vo:IValueObject, defaultValues:Object=null):void
			{
				if (!xml.hasOwnProperty(xmlFieldName))
				{
					if (setOnlyIfNotNull)
						return;
					else
						vo[voFieldName] = undefined;
				}

				var xmlField:XMLList = xml.child(xmlFieldName);

				setVOPropertyFromXML(vo, voFieldName, xmlField);

				// handle default value;
				if (!defaultValues)
					defaultValues = {};

				if (vo[voFieldName] == undefined && defaultValues[voFieldName] != undefined)
					vo[voFieldName] = defaultValues[voFieldName];
			};
		}

		public static function xmlEncoderMaker(voFieldName:String, xmlFieldName:String):Function
		{
			return function(vo:IValueObject):XMLList
			{
				var voField:* = vo[voFieldName];

				var classInfo:XML = DescribeTypeCache.describeType(vo).typeDescription;
				var voDynamic:Boolean = (classInfo.@isDynamic.toString() == "true");

				var fieldType:String;
				if (voDynamic)
					fieldType = 'String';
				else
				{
					var fieldInfo:XML = classInfo.accessor.(@name == voFieldName)[0];
					if (!fieldInfo)
						fieldInfo = classInfo.variable.(@name == voFieldName)[0];
					if (!fieldInfo)
						throw new Error('Property: ' + voFieldName + ' in vo: ' + vo + ' is not found.');
					else
						fieldType = String(fieldInfo.@type);
				}

				var xmlList:XMLList = new XMLList();
				if (TypeIterator.isIterable(voField))
				{
					var iterator:TypeIterator = new TypeIterator(voField);
					while (iterator.hasNext())
					{
						var next:Object = iterator.next();
						if (next)
							xmlList += <{xmlFieldName}>{next.toString()}</{xmlFieldName}>;
					}

					return xmlList;
				}
				else
				{
					if (fieldType == 'Number')
					{
						if (!isNaN(voField))
							xmlList += <{xmlFieldName}>{Number(voField)}</{xmlFieldName}>;
					}
					else if (voField != null)
					{
						if (voField is ObjectProxy)
						{
							var x:XML = <{xmlFieldName} />;
							for (var k:String in voField)
								x.appendChild(<{k}>{voField[k]}</{k}>);
							xmlList += x;
						}
						else
							xmlList += <{xmlFieldName}>{voField.toString()}</{xmlFieldName}>;
					}
				}

				return xmlList;
			};
		}

		/**
		 * Cast an Object of key-value pairs to an array of keyStrings.
		 */
		public static function getObjectKeys(fieldMap:Object):Array
		{
			var fieldList:Array = [];

			for (var i:String in fieldMap)
				fieldList.push(i);

			return fieldList;
		}

		public static function setVOPropertyFromXML(vo:IValueObject, voFieldName:String, xmlField:XMLList):void
		{
			var zeroLengthed:Boolean = xmlField.length() == 0;
			var classInfo:XML = DescribeTypeCache.describeType(vo).typeDescription;
			var voDynamic:Boolean = (classInfo.@isDynamic.toString() == "true");
			if (voDynamic)
			{
				vo[voFieldName] = zeroLengthed ? null : String(xmlField[0]);
				return;
			}

			var fieldInfo:XML = classInfo.accessor.(@name == voFieldName)[0];
			if (!fieldInfo)
				fieldInfo = classInfo.variable.(@name == voFieldName)[0];
			if (!fieldInfo || fieldInfo.@access == 'readonly')
				throw new Error('Property: ' + voFieldName + ' in vo: ' + vo + ' is not an accessable entity');

			var fieldType:String = String(fieldInfo.@type);
			switch (fieldType)
			{
				case 'Boolean':
					vo[voFieldName] = zeroLengthed ? false : xmlField[0] == 'true';
					break;

				case 'Number':
					vo[voFieldName] = zeroLengthed ? NaN : Number(xmlField[0]);
					break;

				case 'int':
					vo[voFieldName] = zeroLengthed ? 0 : int(xmlField[0]);
					break;

				case 'uint':
					vo[voFieldName] = zeroLengthed ? 0 : uint(xmlField[0]);
					break;

				case 'String':
					vo[voFieldName] = zeroLengthed ? null : String(xmlField[0]);
					break;

				default:
					var isIterable:Boolean = fieldType == 'Array';
					var fieldValue:*;
					if (!isIterable)
					{
						var fieldClass:Class = collectionTypeCache[fieldType];
						if (!fieldClass)
						{
							fieldClass = getDefinitionByName(fieldType) as Class;
							fieldValue = new fieldClass();
							if (TypeIterator.isIterable(fieldValue))
							{
								collectionTypeCache[fieldType] = fieldClass;
								isIterable = true;
							}
						}
					}
					else
						fieldValue = [];

					if (isIterable)
					{
						for each (var i:XML in xmlField)
							TypeIterator.push(fieldValue, i);
						vo[voFieldName] = fieldValue;
					}
					else // one to one transformation, this is the worst (and unpredictable) case, we make it a bindable
					{
						if (zeroLengthed)
							break;

						if (vo[voFieldName] is ObjectProxy)
						{
							for each (var j:XML in xmlField[0].children())
								vo[voFieldName][j.name()] = String(j);
						}
						else
							vo[voFieldName] = new ObjectProxy(xmlField);
					}
			}
		}


		// ===============================================================================
		// Utilities function for xml encoding/decoding
		// ===============================================================================
		// Boolean codec
		public static const YES_STRING:String = 'YES';

		public static const NO_STRING:String = 'NO';

		public static const Y_STRING:String = 'Y';

		public static const N_STRING:String = 'N';

		public static const TRUE_STRING:String = 'TRUE';

		public static const FALSE_STRING:String = 'FALSE';

		public static function yesNoDecoder(voProperty:String, xmlProperty:String=null, yesString:String=Y_STRING):Function
		{
			if (xmlProperty == null)
				xmlProperty = voProperty;

			return function(xml:XML, vo:IValueObject, defaultValues:Object=null):void
			{
				if (xml.hasOwnProperty(xmlProperty))
					vo[voProperty] = xml.child(xmlProperty)[0].toUpperCase() == yesString;
			};
		}

		public static function yesNoEncoder(xmlProperty:String, voProperty:String=null, yesString:String=Y_STRING, noString:String=N_STRING):Function
		{
			if (voProperty == null)
				voProperty = xmlProperty;

			return function(vo:IValueObject):XMLList
			{
				var yesNoString:String = vo[voProperty] ? yesString : noString;
				var xml:XML = <{xmlProperty}>{yesNoString}</{xmlProperty}>;
				return XMLList(xml);
			};
		}


		// DateTime codec
		public static function dateTimeDecoder(voProperty:String, xmlProperty:String=null):Function
		{
			if (xmlProperty == null)
				xmlProperty = voProperty;

			return function(xml:XML, vo:IValueObject, defaultValues:Object=null):void
			{
				if (xml.hasOwnProperty(xmlProperty))
					vo[voProperty] = new Date(Number(xml.child(xmlProperty)[0]));
			};
		}

		public static function dateTimeEncoder(xmlProperty:String, voProperty:String=null):Function
		{
			if (voProperty == null)
				voProperty = xmlProperty;

			return function(vo:IValueObject):XMLList
			{
				if (vo[voProperty] == null)
					return new XMLList();

				var xml:XML = <{xmlProperty}>{(vo[voProperty] as Date).getTime()}</{xmlProperty}>;
				return XMLList(xml);
			};
		}


		// complex subnode codec
		public static function subNodeDecoder(voProperty:String, subNodeXPath:Array):Function
		{
			return function(xml:XML, vo:IValueObject, defaultValues:Object=null):void
			{
				if (subNodeXPath == null)
					return;

				var xmlList:XMLList = XMLList(xml);
				while (subNodeXPath.length > 0 && xmlList.length > 0)
				{
					var node:* = subNodeXPath.shift();
					xmlList = xmlList.elements(node);
				}

				if (subNodeXPath.length > 0)
					return;

				setVOPropertyFromXML(vo, voProperty, xmlList);
			};
		}
	}
}
